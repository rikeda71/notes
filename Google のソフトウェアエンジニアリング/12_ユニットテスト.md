# 12章 ユニットテスト

```markdown
要約: ユニットテストはとにかく動作することが大事。
脆いすぐに失敗するテストを防ぐための方法について記載

- 変化しないテストを目指す
- 公開API経由でテスト
- 相互作用ではなく、状態をテスト
- テストコードの完全性・簡潔性を高める
- メソッドではなく、挙動をテストする。挙動に重点を置いてテストを設計する
- テスト対象の挙動にちなんでテストを命名する
- テストにロジックを入れない
- 明確な失敗メッセージを出力するような assertion を実施する
```

## ユニットテストの保守性

- とにかく動作すること = 保守性
- 容易に動かなくなるテストは「保守性が低い」脆いテスト

### 脆いテストを防ぐ

脆いテスト = 本番環境のコードへの無関係な変更で、バグを持っていないのに失敗してしまうテスト

- Google 規模ではこのようなテストは死活問題（全員が全てのコードリポジトリのSTestを実行するので。モノレポなので）
- 変化しないテスト = 脆いテストになり得ない、のが理想
- テストが変化してほしくないタイミング
    - リファクタリング：システムのI/Fを変えずに内部をリファクタリングする場合、システムのテストは変かすべきでない。変化してしまう場合、システムの挙動に影響するリファクタになってしまっているか、テストが適切な抽象化レベルで書かれていなかったことになる
    - 新機能：既存の挙動は影響を受けない状態にとどまるべき。新機能を扱うために既存のテストの方をどこか変更しなければいけない場合、何かが間違っている
    - バグ修正：バグ修正も既存のテストへの更新を要するべきでない
- つまり、テストを追加する改修は**「システムの挙動に破壊的変更を加える場合」**のみであるべき
- ~~~

### 公開API経由のテスト

結構、private メソッドのテストを書きがちなので注意したい

- private メソッドに対してテストを書くのは、利用者目線に立っておらず、結果的に脆いテストになってしまう
- **public メソッドのように公開されているメソッド経由でテストを行う**ことで、実際に利用されるシチュエーションでテストできる。この方法で同等のテストカバレッジを達成し、堅牢なテストになる

### ユニットテストの「ユニット」の定義

- メソッド・クラスが1つか2つの**別のクラスを支援するためだけに存在するのであれば**（ヘルパークラスになっているのであれば）、**それ自体はユニットと扱うべきでない。支援対象のクラスを通じてテストされるべき**
- パッケージまたはクラスが**誰からでもアクセス可能に設計されているのであれば、直接テストされるべきユニットの構成要素**となる
**テスト時はユーザーがクラス・メソッドにアクセスする場合と同じ方法でアクセスする**
- ある範囲の文脈内で有用な一般的な機能を提供するように設計されている（サポートライブラリ）ならユニットとみなされるべき
テストはこのユニットの利用者側とこのユニット自体で被る部分が出てくるが、これは許容される（網羅性重視）

## 相互作用ではなく、状態をテスト

- **何が呼び出されたか（インタラクション）ではなく、APIを実行した結果、状態がどうなったか（ステート）を検証する方が堅牢なテスト**になる
    - インタラクションテストに問題がある場合、最もあり得るのはモッキングフレームワークへの過度な依存
    - ↑を嫌うため、できるだけモックを使わずに本物のオブジェクトを使うことを意識している
    - モックを使うべき箇所については他の章で解説

### 明確なテストを書く

- テストが失敗する理由
    - テスト対象システムに問題があるか不完全←これを早期発見するのがテストの役割
    - テストに欠陥がある。テストが誤った形で作成されている。既存のテストが誤った形だった場合、そのテストは脆いテストである
- テストで落ちた時、↑のどちらであるかを確定させるための助けとなるのがテストの「明確さ」
- 明確なテスト：存在目的・失敗理由が失敗の原因を究明するエンジニアから見てたちどころに明確となるテストのこと。テストが明確であると、テストをドキュメントしたり、新しいテストの基礎の役目をより円滑に果たしたりといった利点ももたらす
- テストが明確性を達成するのを助ける属性
    - 完全性：読者が必要とする全情報をテストが含んでいるか
    - 簡潔性：無関係な情報がテストに含まれていないか

```java
@Test
public void shouldPerformAddition() {
	// 乱雑
	Calculator calculator = new Calculator(new RoudingStraegy(),
			"unused", ENABLE_COSINE_FEATURE, 0.01, calculusEngine, false);
	// 不完全。5とはなに？
	int result = calculator.calculate(newTestCalculatoion())
	assertThat(result).isEqualTo(5);
}
```

```java
@Test
public void shouldPerformAddition() {
	Calculator calculator = newCalculator(); // 簡潔に
	// テストを読む上での情報の完全性を担保
	int result = calculator.calculate(newCalculation(2, Operation.PLUS, 3));
	assertThat(result).isEqualTo(5);
}
```

- 完全性・簡潔性を達成するために上記の例のように DRY 原則に反することもある。
ただ、テストを読む上では価値のある書き方となっている
（プロダクションコードのようにテストコードも扱うが、実際に本番で動作しないコードには DRY 原則を適応しない手もあるということ）

### メソッドではなく、挙動をテスト

- メソッドが各々に対応するテストメソッドを持つように、テストの構造をコードの構造に合わせるようなテストコードは、時間経過とともにテスト対象のメソッドが複雑になることで問題となる。実際は何をやっているのか推論するのが難しくなる
- ↑のような状態を避けるため、各メソッド向けにテストを書くのではなく、各挙動に対してテストを書くべき。システムの状態に応じて、一連の入力へどう反応するか確認するテストを1つ1つ用意する

以下はメソッド駆動のテストを挙動駆動に書き換えた例である。
条件ごとに新しいテストを用意している。

```java
@Test
public void testDisplayTransactionResults() {
	transactionProcessor.displayTransactionResults( 
			newUserWithBalance(
					LOW_BALANCE_THRESHOLD.plus(dollars(2))), 
			new Transaction("何かのアイテム", dollars(3)));

	assertThat(ui.getText()).contains(" 購入した物は何かのアイテム ");
	assertThat(ui.getText()).contains(" 残高が少ない ");
}
```

```java
@Test
public void displayTransactionResults_showsItemName() {
	transactionProcessor.displayTransactionResults(
			new User(), new Transaction("何かのアイテム"));
	assertThat(ui.getText()).contains("購入した物は何かのアイテム");
}

@Test
public void displayTransactionResults_showsLowBalanceWarning() {
	transactionProcessor.displayTransactionResults(
			newUserWithBalance(
					LOW_BALANCE_THRESHOLD.plus(dollars(2))),
			 new Transaction("何かのアイテム", dollars(3)));
	assertThat(ui.getText()).contains("残高が少ない");
}
```

■ 挙動駆動のテストの利点

- 自然言語を読むのに近い形で読める
- 各テストの範囲が比較的限られているので、原因と結果をより明確に表現可能
- 各テストが短くて説明的なので、テストされている事象が把握しやすい

挙動駆動なテストの書き方

- given when then のように何を用意して、どういった時に何が起こるかをテストする
    - spock とかはこれをサポートしている
- テストの名称はテスト対象の挙動を含める。優れた名称は、システムに対して行われる動作と期待される結果の両方を説明する
    - jest とかはこの形式
    - 実行される関数名 ⇒ 期待される挙動（`should~~~` ）という階層構造でテスト設計ができる
        - 困ったら `should` をテスト名に含めるといい
    - 実際に動作するコードより冗長だが、テストは何を検証しているかを明確にするべきなので、冗長さは許容される
- テストにロジックを入れないこと
    - if や for をテストに含めない
    - 気の利いたロジックより、単純なコードで突き通すべき。ある程度の重複も意味の分かりやすさのために許容する
- テストが失敗するときのメッセージを明確にするようにテストを設計する
    - True であることを保証するのでなく、ある値になることを保証するようにすると、テストが失敗した時に想定した値と違うことがわかりやすい

## テストを書くうえでその他のテクニック

■ DAMP（Descriptive And Meaningful Phrases）

- 説明的かつ意味がわかりやすい言い回し
- DRY を置き換えるものではなく、補うものとする

■ ヘルパーメソッドの作り方

- 名前付きパラメータやビルダーパターンを使ったヘルパーメソッドを用意
- テストケースごとに必要なパラメータだけ上書きすることで、テストの前提としているパラメータがわかりやすくなる
- テストに簡単なロジックを含む必要がある場合、それをヘルパーメソッドとすることで可読性が上がるかもしれない

■ 初期設定の共有

- 初期設定の最良のユースケースは、テスト対象オブジェクトとその協調動作対象オブジェクト群を構築すること
- 明示的に特定の値に関心を持つテストの場合、テスト対象オブジェクトを上書き・再定義するべき
