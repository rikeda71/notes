# 13章 テストダブル

```markdown
要約: テストダブルは極力使わない上で、テストダブルの種類（フェイク、スタブ、モック）を解説し、
それぞれ利用するべき場合やベストプラクティスについて解説

- テストダブルより本物の実装が優先されるべき
- テスト内で本物の実装が利用できないなら、フェイク（In Memory DB や簡易的なAPI）が理想的であることが多い
- スタブ、モックはテストを脆いテストにしやすい。多用はせず適切な箇所で使う
```

# テストダブル

- テストダブル（test double）：テスト内で実装の代役を務めることのできるオブジェクト・関数
- モック（mock）はテストダブルの個別具体的な側面を指す場合に使われる

## テストダブルのソフトウェア開発への影響

テストダブルを利用することによるトレードオフ・複雑さ

- テスト可能性
    - コードをテスト可能な状態に保つ必要がある
    - 例えば DB の代わりにテストダブルを利用することができる程度の柔軟性を担保する必要がある
- 応用性
    - テストダブルを不適切に利用すると、テストが脆くなりやすい
    - テストダブルを利用するのは不適切な場合は多く、代わりに本物の実装の利用を優先すべきである場合が多い
- 忠実性
    - テストダブルの挙動を置き換え対象の本物の挙動にどれだけ近いか
    - テストダブルが本物の挙動と著しく違えば、テストダブルを使ったテストに価値はない

## Google でのテストダブル

- 長い時間が経つにつれ、モッキングフレームワークを使ったテストの代償を悟った。テストが書くのが簡単になるが、バグを滅多に発見しないようなテストの割に保守性が低かった
- Google では、多くのエンジニアが現実的なテストを書く方を優先し、モッキングフレームワークの利用を避けている

### 現実的な実装を優先する理由

- 正常に動作しているという点での信頼が得られる
    - テストダブルに依存しすぎると、同程度の信頼を得るためにインテグレーションテストを実行したり、手動で動作確認する必要が出てくる
- テスト対象が依存している実装にバグが混入している場合、テストが落ちてくれる。事前にバグがあることに気づく機会が得られる

### いつ本物の実装を使うべきか決める方法

- 以下のようなオブジェクト・メソッドである場合
    - 高速
        - 高速であるかの判断は難しいが、とりあえず本物を使っておき、テストに時間がかかると判断できた段階でテストダブルに置き換えるとよい
    - 決定的
        - 常に同じ結果が保証できること
        - 非決定的な実装
            - マルチスレッドを使っている
            - テストの制御下にない、外部サービスへの依存関係がある状態。HTTPサーバーやDBなど
                - テストダブルの利用が現実的でない場合、密閉されたインスタンス内でこれらの通信を行う
    - 持っている依存関係が単純
        - オブジェクトの依存先が少ない場合
        - 依存が多い場合も上述のファクトリーメソッドやDIによる依存が可能か検討
- **値オブジェクトだと必ず上記を満たすはずであるため、本物の実装を使うべき**

## テストダブルの基本概念

### シーム（seam：繋ぎ目）

- テストダブルを利用できるようにすることで、コードをテスト可能とする方法
- 一般的には Dependency Injection を利用することで、シームを導入する
    - Java では Guice や Dagger が Google 社内で使われるDIフレームワーク
- ↑Python や JavaScript などの動的型付け言語では、ここの関数やオブジェクトのメソッドを動的に置換可能なので、DIの重要性は低い
    - jest.mock() とかで置換するよね

### モッキングフレームワーク

- テストダブルをテスト内で容易に作成できるようにしてくれるソフトウェアライブラリ
- Google 社内では Java：Mockito、C++ では、Googletest の googlemock を利用

## テストダブルのテクニック

以下のテクニックを把握しておくことで、テストダブルを使う必要に迫られた際に利用すべき適切なテクニックがわかる可能性が比較的高くなる

### フェイキング

- 本番環境に適していないが、本物の実装同様に振る舞うAPIの軽量実装
- 例えば、In Memory DB など
- 利点
    - 本物の実装同様に振る舞える
    - 高速
        - ただし、動作が高速なだけで、いずれは遅くて信頼性のないテストにつながる可能性がある
- いつ使う？
    - フェイクは本物同様に振る舞う必要があるため、意外と多くの労力とドメイン経験が必要
        - 保守も必要。実装が変わるにつれて、フェイクの振る舞いも変わる
    - 保守が必要なので、**コード内の依存関係の最上位ノードにおいてのみフェイクを利用するとよい**
        - 例えば DB や HTTP サーバーへの通信など
            - **さまざまなサービス、プログラミング言語から参照されるHTTPサーバーの場合、モックサーバーを用意する手もある**
    - 保守できない場合はいずれにせよ本物の実装を使う方がいい
- 忠実性
    - フェイクは本物の実装の持つAPI契約への忠実性を維持すべき
        - 例えば、DB のフェイクであれば、id が既存のものかどうかで処理を変えるなどの振舞いを持つべき
    - ただし、完全でなくてもいい。例えばレイテンシやリソース消費は再現できないし、テストの観点から見た場合に忠実性を持っておけば良い
- フェイクのテスト
    - 本物の実装のAPIに準拠していることを担保するためにテストすべき
    - フェイク用のテストはAPIの公開インターフェースに対してテストを書き、本物の実装とフェイクの実装の両方で同じ振る舞いになるかを検証するテストにする方法がある（**契約テスト**）

### スタビング

- 関数が返すべき正確な値を関数に対して指定する（返り値をスタブ（stub）する）
- Mockito だと以下のような感じ

```java
// lookupUser(USER_ID) の返り値をスタブしている
when(mockAuthorizationService.lookupUser(USER_ID)).thenReturn(null);
```

- スタビングによる危険
    - テストが不明確：スタブ化される関数の挙動を定義するためのコードが増える
        - **スタブの意図を理解するために頭の中で処理をステップ実行してしまっているなら、スタブは使うべきでない**
    - テストが脆くなる：本体実装が変わるとスタブも更新する可能性が出てくる。テストはユーザに即したAPI挙動が変化する場合にのみ変化させるのが理想であるため、これは理想から外れている
    - テストの効果が落ちる
        - 本物の実装のように振る舞う保証ができない
            - テスト対象システムが本物の実装の契約に依存している場合はスタビングは利用すべきでない。契約の詳細を複製することになるため
- スタビングが適切な場合
    - テスト対象システムをある状態に遷移させるために、ある特定の値を返さなければいけない場合
        - スタブ化された関数は、目的が明確になるようにテストのアサーションと直接関係があるべき

### インタラクションテスト

- 関数がどのように呼び出されるかをその関数の実装を呼び出すことなしに検証する方法
- 関数の引数や呼び出し回数をテスト内で指定する
- **これが俗にモッキングと呼ばれる**

- インタラクションテスト < ステートテスト
    - 何が呼ばれたかではなく、どういう状態になったかのテストを優先する
    - インタラクションテストは、テスト対象システムの実装詳細をテスト内に公開しているため、実装が変わったらインタラクションテストの内容も修正する必要があり、テストが脆い
- インタラクションテストが適切な場合
    - 本物の実装またはフェイクが使えない場合（本物の実装が遅すぎる、フェイクが存在しないなど）
    - 関数への呼び出し回数・順序の違いが挙動に影響する（呼び出し回数などである程度挙動を検証できる）
- ベストプラクティス
    - 状態変更型関数に対してのみ、インタラクションテストを利用する
        - 例えば、send~~~, save~~~ など
        - find~~~, get~~~ では使わない。値を検証する
    - 過剰な指定を避ける
        - どの関数と引数が検証されるかを極力指定しない
            - テストの可読性が上がる
        - Mockito だと、any() を使う。テストを分割して、テストごとにモックを作成する
