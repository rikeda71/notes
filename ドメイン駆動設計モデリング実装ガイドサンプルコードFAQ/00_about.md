# ドメイン駆動設計 モデリング/実装ガイド & サンプルコード & FAQ

- URL: https://booth.pm/ja/items/1835632
- 価格: 2,000 * 2(モデリング/実装ガイド・サンプルコード & FAQ で2冊)

## 概要

### モデリング/実装ガイド

初めてDDDを学ぶ方、もしくは実際に着手して「難しい！！」と感じているエンジニアの方を対象とした、ドメイン駆動設計(以下、DDD)についての解説書。

迷子になりがちな「DDDの目的」や「モデル」の解説からはじめ、
具体的なモデリングを行い実装まで落とす事例を元に、DDDの魅力や効果を体感

---

### サンプルコード & FAQ

「モデリング」「集約」「テスト」について解説し、その他のトピックでは頻出の質問への回答と具体的なサンプルコードを示しました。

## 興味を持った理由

- DDD について概要を知りたい
- エリック・エヴァンス本や実践ドメイン駆動設計を読むための足掛かりにしたい

## 要点

### DDD 概要

#### DDD

- ドメイン = ソフトウェアで問題解決しようとする対象領域
- DDD のアプローチ
    > 多くのプロジェクトは、モデリングを行っても最終的に大きな利益を得られないまま終わります。DDD は、モデリングから劇的な利益を得られたプロジェクトから、成功するパターンを抽出します。

    - DDD = **モデリングによってソフトウェアの価値を高める**
- 課題ドリブンを大切に
    - DDD のルールそのものに従うことより、何を目的に DDD のルールに従うかを念頭におく
    - **DDD が向いているのはドメインが複雑な場合**。シンプルなロジックや CRUD などであれば DDD を採用するコストが利点を上回ってしまう

#### モデル

- モデル = 問題解決のために、物事の特定の側面を抽象化したもの
    - ドメインモデル：ドメインの問題を解決するためのモデル（基本的にはこっちを指す）
    - データモデル：データの永続化方法を決めるためのモデル
    - モデルは問題解決のために必要な要素だけ取り込む
- 良いモデルを作るには？
    - ドメインエキスパートと会話
    - 運用して得られた発見をモデルに還元
        - 常に改善していく
- ユビキタス言語：発見したモデルの言葉を全ての場所で使う。
    - 開発者もビジネスサイドも
    - 会話でもドキュメントでもコードでも同じ言葉を使う
    - **英語が有利（コードに落とし込みやすい）。日本語を使いたい場合は対訳を用意**

### ドメインモデリング

- モデリングにはユースケース図やドメインモデル図 RDRA（リレーションシップ駆動要件分析）や ICONIX といったモデリング法がある
- ユースケース図を作成してから（ユースケースを決定してから）、ドメインモデル図を作成すると良い
    - PlantUML などが有用
    - モデリングには 1,2 時間ぐらいを制限時間として取り組む
    - ドメインモデルは実装を開始する前に更新する
- ドメインモデル図は簡略化したクラス図のようなもの
    - オブジェクトの代表的な属性を書く。メソッドは書かない
    - ルール・制約を吹き出しに書く
    - オブジェクト動詞の関連を示す
    - 多重度を定義
    - 集約の範囲を定義
    - 具体例を書いても良い
    - 集約内の参照はインスタンス参照となり、「◆-」で表す
    - 集約外の参照は ID 参照となり、「→」 で表す
- ドメインモデルをドメインモデル図を元に実装する。
上記ドメインモデル図を参考に Java + Lombok で実装した例は以下

    ```java
    @Getter
    // setter は必要なものだけ　public にするので、
    // @Setter
    public class Task {
      private Long id;
      private TaskStatus taskStatus;
      private String naem;
      private LocalDate dueDate;
      private int postponeCount;

      private static final int POSTPONE_MAX_COUNT = 3;

      /**
       * constructor: 新規登録の場合
       */
      public Task(String name, LocalDate dueDate) {
        if (name == null || dueDate == null) {
          throw new IllegalArgumentException("必須項目が設定されていません");
        }
        this.name = name;
        this.dueDate = dueDate;
        this.taskStatus = TaskStatus.UNDONE;
        this.postponeCount = 0;
      }

      // 延期時の処理
      public void postpone() {
        if (postponeCount >= POSTPONE_MAX_COUNT) {
          throw new IllegalArgumentException("最大遅延回数を超過しています");
        }
        dueDate.plusDays(1L);
        postponeCount++;
      }
    }
    ```

- ポイント
    - ドメインモデルに状態遷移用のメソッドを実装
        - ドメインモデルにドメイン知識を持たせる
    - setter を用意しない。値の更新は状態変化用のメソッドで行う
    そうすることで、他の UseCase で不用意に値を更新させないようにできる

### ドメイン層オブジェクト設計の基本方針

- ドメインモデルの知識を対応するオブジェクトに書く
    - ドメインモデル図の吹き出しの内容はドメイン層で実装させる
- 常に正しいインスタンスだけを存在させる
    - **生成条件の強制**：全てのインスタンスはコンストラクタ・ファクトリーメソッドのいずれかを経由して生成。**デフォルトコンストラクタはこれに反しているので、意味のある生成メソッドだけが存在するようにする**
    - **ミューテーション条件の強制**：正しいミューテーションを起こすメソッドのみを外部に公開する。例えば、setter method はこれに反するので公開しない

## DDD 固有のモデリング手法

### 集約

集約：必ず守りたい強い生合成を持ったオブジェクトのまとまり

- **設計/実装時のルール**
    - **強い生合成確保が必要なものを1つの集約にする**
        - 全てのオブジェクトはいずれかの集約に所属させる
        - 集約のオブジェクトを扱うときの親となるオブジェクトを**集約ルート**と呼び、集約ごとに1つずつ存在
    - **トランザクションを必ず1つにする**
        - 集約単位でリポジトリを実装。
            - 集約単位でリポジトリからオブジェクトを取得
            - 集約単位でリポジトリに渡して更新
- 集約の境界の決め方
    - 整合性を確保する必要の強さ
    - トランザクションの範囲の適切さ
        - 必要以上にロックをとってしまい、問題となるので
        - **トランザクションの観点からも集約を決定することが大事**

### 境界づけられたコンテキスト

境界づけられたコンテキスト：特定のモデルを定義・適用する境界を明示的に示したもの。サブシステム・チームなど

- システムが大規模になると、関係者全てで統一したモデルを作ることは難しい
- モデルが適応される範囲を明示的に定義し、それぞれの中でモデル言語の統一を目指す
- つまり、コンテキストごとにモデルを定義する

## 設計の基本原則

### 凝集度・結合度

**高凝集・低結合**を目指すことが設計の基本原則となる

- 凝集度：1つのクラスについて「責務、データ、振る舞いの関連の強さ」の尺度。高いほうが良い
    - 責務：クラスの役割
- 結合度：複数のクラス同士が依存している度合いの尺度。低いほうが良い

### アーキテクチャ

DDD に適応する際に最も扱いやすいのはオニオンアーキテクチャ

- **Web アプリに適応するのにシンプル**
- **レイヤー責務の思想**
    - クリーンアーキテクチャのエンティティ層は「企業一般で適応できるビジネスルール」を指す（「Enterprise wide business rules」を直訳するなら）
    - DDD ではコンテキストごとにモデルを検討するが、その思想とエンティティ層の考え方がマッチしていない
- 「エンティティ層」という名称。DDD ではドメインオブジェクトの一種がエンティティなので、ドメイン層と呼びたい。オニオンアーキテクチャでは「ドメイン層」

---

レイヤードアーキテクチャ

- ビジネスロジック層を「ユースケースを実現する層」と「ドメイン知識を表現する層」の2つにわけたアーキテクチャ
- ドメイン層がインフラ層に依存してしまうことが課題

オニオンアーキテクチャ

- DIP によって、ドメイン層とインフラ層の依存関係を逆転
    - リポジトリは interface：ドメイン層、実装：インフラ層に定義
    - ドメイン層を特定のインフラ技術に依存させずに表現できる
    （ドメイン層がインフラ層に依存しないようにできる）

ヘキサゴナルアーキテクチャ（ポートアンドアダプターアーキテクチャ）

- 実践ドメイン駆動設計本で紹介
- アプリケーションが外界とコミュニケーションする際は、専用のポート・アダプターを作成して通信させるという思想
- オニオンアーキテクチャの大元となったアーキテクチャ

クリーンアーキテクチャ

- ヘキサゴナルアーキテクチャの Application 層が UseCases 層と Entities 層、Adaptors 層が Interface Adapters 層と紐づく

## ドメイン層の実装

ドメイン層では**戦術的設計パターン**を使用してドメインモデルを表現する

- 戦術的設計パターン
    - ドメインモデルを表現するもの（ドメインオブジェクト）
        - エンティティ
        - 値オブジェクト
        - ドメインイベント
    - ドメインオブジェクトを使用するもの
        - リポジトリ
        - ファクトリ
        - ドメインサービス

### ドメインオブジェクト

- エンティティ
    - 識別する際に利用するものが属性値ではなく識別子
    - 可変なもの
- 値オブジェクト
    - 不変なもの
    - 業務ルールを表現したもの
    - 属性値で識別
- エンティティが値オブジェクトを利用

### ドメインオブジェクトを使用するもの

- ドメインサービス：モデルをオブジェクトとして表現すると無理があるものの表現に利用
    - 例：集合に対する操作、複雑な演算処理など
    - **極力エンティティと値オブジェクトで実装し、避けられない場合のみドメインサービスを利用**
        - 手続き的になるので、ビジネスロジック層の感覚で書いてしまいがちなので注意
    - **Service であることは明示的なのでなるべくクラス名に Service をつけないほうが良い**
        - UserService とかだと、ユーザに関する処理全てを司る Fat Class になり得る可能性がある
- リポジトリ：集約単位で永続化層へのアクセスを許可するもの
    - 集約ごとに1つだけ
    - **リポジトリに渡すもの・返されるものは集約ルートのエンティティ**
    - **リポジトリは List のように扱う**
        - List は「ユーザ登録」、「ユーザを退会」といった処理を持たない
        - List に持たせないようなメソッドを持っている = ドメイン知識を持っていることにつながるので、このような状態になっていたら責務過剰なので別のクラスに責務を委譲する
    - DB の値からエンティティを再構成するには、エンティティのコンストラクタを利用したり、リポジトリ ⇒ エンティティ専用の値生成用のメソッド（例えば fromRepository）などを利用
        - この処理はインフラ層の中で実施
    - ソートもリポジトリで実装する。ソート順をリポジトリ上のメソッドの引数で指定できるようにし、order by 句を引数から生成する
    - インタフェースはドメイン層におくと良い
        - 集約の範囲を明示するため。
        - リポジトリのメソッドはエンティティや値オブジェクトをどの単位で永続化するかを定義するので、ドメイン層
        - DIP によりドメイン層のドメインサービスからもリポジトリを参照してもようになることも理由
    - エンティティの削除は ID だけを渡すで良い
        - 集合に関する操作として、削除したいオブジェクトを識別子を指定して削除することは自然
- ファクトリー：オブジェクトの生成ロジックが複雑な場合、他の集約を参照する必要がある場合に生成の責務専用のオブジェクトとなりえるもの。ドメインサービスの一種
    - ドメイン知識の表現のためにリポジトリを参照・使用できる
- そのほか、enum、ファーストクラスコレクションを利用しても良い

### 集約間の整合性確保

1. ユースケース層のメソッドで確保
2. ドメインイベントを用いて、結果整合性で担保

1 だと、別のユースケースクラスのメソッドで整合性を破る処理を書くことが可能になってしまう
2 だと確実に整合性が確保できるが実装が複雑。SpringBoot だと [EventListener](https://spring.pleiades.io/spring-framework/docs/current/javadoc-api/org/springframework/context/event/EventListener.html) などを利用する。ドメインイベントを利用するときは、ドメイン層が FW の機能に依存しがちだが許容する

#### EventListener の利用例

https://tech.excite.co.jp/entry/2021/12/17/102114


